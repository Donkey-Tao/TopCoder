<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>You are given the ints <b>N</b> and <b>K</b>.</p>

Let S be the set of all arrays that have the following properties:
<ul>
<li>The length of the array is exactly <b>N</b>.</li>
<li>Each element in the array is an integer between 1 and <b>N</b>, inclusive.</li>
<li>Each number occurs in the array at most <b>K</b> times.</li>
</ul>

Morphing an array A is an operation that consists of three steps:
<ol>
<li>Choose two distinct integers x and y, each between 1 and <b>N</b>, inclusive.</li>
<li>Change the values of some elements of A: All elements of A that had the value x will now have the value y and vice versa.</li>
<li>Finally, swap two elements of A: the elements with the 1-based indices x and y.</li>
</ol>

For example, suppose that A = [1,3,3,4].
One possible morphing of this array will look as follows:
<ol>
<li>We choose x=1 and y=3.</li>
<li>After changing the values in A, we have the array [3,1,1,4].</li>
<li>Then, after the swap we have the final result: the array [1,1,3,4].</li>
</ol>

<p>Note that if we morph an array that belongs into S, the result will always belong into S as well.</p>

<p>We are interested in a subset T of S with the property that any array in S can be produced from some array in T by a sequence of zero or more morphing operations. Find the smallest possible size of such subset T, and return its size modulo 1,000,000,007.</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>Morphling</td></tr><tr><td>Method:</td><td>findsz</td></tr><tr><td>Parameters:</td><td>int, int</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int findsz(int N, int K)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>N</b> will be between 1 and 100, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>K</b> will be between 1 and min(25, <b>N</b>), inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>1</pre></td></tr><tr><td><pre>1</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1</pre></td></tr><tr><td><table><tr><td colspan="2">The only valid array is [1].
The subset T must contain this array.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>2</pre></td></tr><tr><td><pre>1</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2"><p>There are two arrays in S: [1,2] and [2,1].</p>
<p>The morphing operation always changes [1,2] into [1,2] and it always changes [2,1] into [2,1].
Therefore we need to include both arrays into T.</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>2</pre></td></tr><tr><td><pre>2</pre></td></tr></table></td></tr><tr><td><pre>Returns: 3</pre></td></tr><tr><td><table><tr><td colspan="2"><p>There are four arrays in S: [1,2], [2,1], [1,1], [2,2].</p>
<p>The morphing operation allows to transform [1,1] to [2,2], so only one of this should be included into T.</p>
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>1</pre></td></tr></table></td></tr><tr><td><pre>Returns: 3</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>3</pre></td></tr><tr><td><pre>3</pre></td></tr></table></td></tr><tr><td><pre>Returns: 7</pre></td></tr><tr><td><table><tr><td colspan="2"><p>Here the set S contains 27 different arrays.
Some of these arrays can be produced from other arrays by morphing.</p>
<p>The smallest possible subset T with the required property consists of only 7 of these arrays.</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>10</pre></td></tr><tr><td><pre>1</pre></td></tr></table></td></tr><tr><td><pre>Returns: 42</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">6)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>48</pre></td></tr><tr><td><pre>18</pre></td></tr></table></td></tr><tr><td><pre>Returns: 270440792</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">7)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>100</pre></td></tr><tr><td><pre>25</pre></td></tr></table></td></tr><tr><td><pre>Returns: 796177038</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>

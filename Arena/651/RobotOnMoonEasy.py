import math,string,itertools,fractions,heapq,collections,re,array,bisect,random

class RobotOnMoonEasy:
    def isSafeCommand(self, board, S):
        rows = len(board)
        cols = len(board[0])
        for r in xrange(rows):
            for l in xrange(cols):
                if board[r][l] == 'S':
                    i = r;
                    j = l;

        dead = "Dead";
        alive = "Alive";
        print(i, j)
        for c in S:
           if c == 'U':
               if i - 1 < 0:
                   return dead
               elif board[i - 1][j] != '#':
                   i = i - 1;
           elif c == 'D':
               if i + 1 >= rows:
                   return dead
               elif board[i + 1][j] != '#':
                   i = i + 1;
           elif c == 'L':
               if j - 1 < 0:
                   return dead
               elif board[i][j - 1] != '#':
                   j = j - 1;
           else:
               if j + 1 >= cols:
                   return dead
               elif board[i][j + 1] != '#':
                   j = j + 1;

        return alive

# BEGIN KAWIGIEDIT TESTING
# Generated by KawigiEdit-pf 2.3.0
import sys
import time
def KawigiEdit_RunTest(testNum, p0, p1, hasAnswer, p2):
	sys.stdout.write(str("Test ") + str(testNum) + str(": [") + str("{"))
	for i in range(len(p0)):
		if (i > 0):
			sys.stdout.write(str(","))
		
		sys.stdout.write(str("\"") + str(p0[i]) + str("\""))
	
	sys.stdout.write(str("}") + str(",") + str("\"") + str(p1) + str("\""))
	print(str("]"))
	obj = RobotOnMoonEasy()
	startTime = time.clock()
	answer = obj.isSafeCommand(p0, p1)
	endTime = time.clock()
	res = True
	print(str("Time: ") + str((endTime - startTime)) + str(" seconds"))
	if (hasAnswer):
		print(str("Desired answer:"))
		print(str("\t") + str("\"") + str(p2) + str("\""))
	
	print(str("Your answer:"))
	print(str("\t") + str("\"") + str(answer) + str("\""))
	if (hasAnswer):
		res = answer == p2
	
	if (not res):
		print(str("DOESN'T MATCH!!!!"))
	elif ((endTime - startTime) >= 2):
		print(str("FAIL the timeout"))
		res = False
	elif (hasAnswer):
		print(str("Match :-)"))
	else:
		print(str("OK, but is it right?"))
	
	print(str(""))
	return res

all_right = True
tests_disabled = False


# ----- test 0 -----
disabled = False
p0 = (".....",".###.","..S#.","...#.")
p1 = "URURURURUR"
p2 = "Alive"
all_right = (disabled or KawigiEdit_RunTest(0, p0, p1, True, p2) ) and all_right
tests_disabled = tests_disabled or disabled
# ------------------

# ----- test 1 -----
disabled = False
p0 = (".....",".###.","..S..","...#.")
p1 = "URURURURUR"
p2 = "Dead"
all_right = (disabled or KawigiEdit_RunTest(1, p0, p1, True, p2) ) and all_right
tests_disabled = tests_disabled or disabled
# ------------------

# ----- test 2 -----
disabled = False
p0 = (".....",".###.","..S..","...#.")
p1 = "URURU"
p2 = "Alive"
all_right = (disabled or KawigiEdit_RunTest(2, p0, p1, True, p2) ) and all_right
tests_disabled = tests_disabled or disabled
# ------------------

# ----- test 3 -----
disabled = False
p0 = ("#####","#...#","#.S.#","#...#","#####")
p1 = "DRULURLDRULRUDLRULDLRULDRLURLUUUURRRRDDLLDD"
p2 = "Alive"
all_right = (disabled or KawigiEdit_RunTest(3, p0, p1, True, p2) ) and all_right
tests_disabled = tests_disabled or disabled
# ------------------

# ----- test 4 -----
disabled = False
p0 = ("#####","#...#","#.S.#","#...#","#.###")
p1 = "DRULURLDRULRUDLRULDLRULDRLURLUUUURRRRDDLLDD"
p2 = "Dead"
all_right = (disabled or KawigiEdit_RunTest(4, p0, p1, True, p2) ) and all_right
tests_disabled = tests_disabled or disabled
# ------------------

# ----- test 5 -----
disabled = False
p0 = ("S",)
p1 = "R"
p2 = "Dead"
all_right = (disabled or KawigiEdit_RunTest(5, p0, p1, True, p2) ) and all_right
tests_disabled = tests_disabled or disabled
# ------------------

if (all_right):
	if (tests_disabled):
		print(str("You're a stud (but some test cases were disabled)!"))
	else:
		print(str("You're a stud (at least on given cases)!"))
	
else:
	print(str("Some of the test cases had errors."))

# PROBLEM STATEMENT
# There is a robot on the moon.
# You are given a tuple (string) board containing the map of a rectangular area.
# The robot is currently located somewhere in that area.
# In the map, the character '.' (period) represents an empty square, 'S' represents an empty square that currently contains the robot, and '#' represents an obstacle.
# 
# 
# You are also given a string S.
# This string represents a sequence of commands we are going to send to the robot.
# Each character in S is one of 'U', 'D', 'L', and 'R', representing a step up, down, left, and right, respectively.
# 
# 
# Whenever the robot receives a command, one of three things will happen:
# 
# If the requested move leads to an empty square, the robot performs the move.
# If the requested move leads to a square with an obstacle, the robot ignores the command and remains in place.
# If the requested move leads out of the mapped area, the robot leaves the mapped area and dies immediately.
# 
# 
# 
# Given the map and the sequence of commands, compute whether the robot will survive.
# Return "Alive" (quotes for clarity) if the robot is still somewhere on the map after the last command.
# Otherwise, return "Dead".
# Note that the return value is case-sensitive.
# 
# DEFINITION
# Class:RobotOnMoonEasy
# Method:isSafeCommand
# Parameters:tuple (string), string
# Returns:string
# Method signature:def isSafeCommand(self, board, S):
# 
# 
# NOTES
# -The direction 'U' corresponds to moving from board[i][j] to board[i-1][j]. The direction 'L' corresponds to moving from board[i][j] to board[i][j-1].
# 
# 
# CONSTRAINTS
# -board will contain between 1 and 50 elements, inclusive.
# -Each element of board will contain between 1 and 50 characters.
# -Each element of board will contain the same number of characters.
# -The characters in board will be '.', '#' or 'S'.
# -There will be exactly one 'S' in board.
# -S will contain between 1 and 50 characters, inclusive.
# -Each character in S will be one of 'U', 'D', 'L', 'R'.
# 
# 
# EXAMPLES
# 
# 0)
# {".....",
#  ".###.",
#  "..S#.",
#  "...#."}
# "URURURURUR"
# 
# Returns: "Alive"
# 
# The robot will never move from its starting location: commands 'U' and 'R' are sending it into obstacles, so the robot ignores them.
# 
# 1)
# {".....",
#  ".###.",
#  "..S..",
#  "...#."}
# "URURURURUR"
# 
# Returns: "Dead"
# 
# This time there is no obstacle on the robot's right side. Its execution of commands will look as follows:
# 
# 'U' leads into an obstacle. The robot ignores it.
# 'R' leads into an empty square. The robot makes a step to the right.
# 'U' leads into an obstacle. The robot ignores it.
# 'R' leads into an empty square. The robot makes a step to the right.
# The next 'U' now leads into an empty square. The robot makes a step up. After this step, the robot is in row 1, column 4. (Both indices are 0-based.)
# 'R' leads out of the map. The robot steps out of the map and dies. The remaining four commands never get executed - the robot is already dead.
# 
# 
# 2)
# {".....",
#  ".###.",
#  "..S..",
#  "...#."}
# "URURU"
# 
# Returns: "Alive"
# 
# 
# 
# 3)
# {"#####",
#  "#...#",
#  "#.S.#",
#  "#...#",
#  "#####"}
# "DRULURLDRULRUDLRULDLRULDRLURLUUUURRRRDDLLDD"
# 
# Returns: "Alive"
# 
# There are obstacles all around the map. Regardless of how the robot moves, it is safe - the obstacles will prevent it from leaving the map.
# 
# 4)
# {"#####",
#  "#...#",
#  "#.S.#",
#  "#...#",
#  "#.###"}
# "DRULURLDRULRUDLRULDLRULDRLURLUUUURRRRDDLLDD"
# 
# Returns: "Dead"
# 
# After some steps the robot will leave the map from the only empty square in the bottom row of the map.
# 
# 5)
# {"S"}
# "R"
# 
# Returns: "Dead"
# 
# 
# 
# END KAWIGIEDIT TESTING
#Powered by KawigiEdit-pf 2.3.0!
